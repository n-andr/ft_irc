#!/usr/bin/expect -f
# Runs the server, authenticates two nc clients, verifies server stdout markers,
# and checks two-way PRIVMSG delivery.
#
# Env overrides (optional): HOST, PORT, PASS, SERVER_CMD
# macOS: brew install expect
# Linux: sudo apt-get install expect (or equivalent)

set timeout 5
set host [expr {[info exists env(HOST)] ? $env(HOST) : "127.0.0.1"}]
set port [expr {[info exists env(PORT)] ? $env(PORT) : "6667"}]
set pass [expr {[info exists env(PASS)] ? $env(PASS) : "pass"}]
set server_cmd [expr {[info exists env(SERVER_CMD)] ? $env(SERVER_CMD) : "./ircserv 6667 pass"}]

# Optional: save a combined log of everything Expect sees (helpful for debugging)
# log_file -a tests/logs/pm_two_clients_serverstdout.log

# --- start server and capture BOTH stdout+stderr ---
# We use 'sh -c "... 2>&1"' so Expect sees stderr too.
spawn sh -c "$server_cmd 2>&1"
set server_id $spawn_id
set server_pid [exp_pid -i $server_id]

# small grace for server boot
after 200

proc wait_for_server_line {server_id pattern label} {
  set ::timeout 5
  # Listen on server's stdout for a regex
  expect -i $server_id {
    -re $pattern { return }
    timeout { puts "FAIL: timeout waiting for server: $label"; exit 1 }
  }
}

# --- helper to start a client and auth while checking server stdout ---
proc start_and_auth {server_id host port pass nick real} {
  # start nc client
  spawn nc -C $host $port
  set cid $spawn_id

  # send PASS and check server stdout marker
  set spawn_id $cid
  send "PASS $pass\r\n"
  wait_for_server_line $server_id {Correct password} "Correct password ($nick)"

  # send NICK and check server stdout marker
  send "NICK $nick\r\n"
  wait_for_server_line $server_id {NICK successful} "NICK successful ($nick)"

  # send USER and check server stdout marker
  send "USER $nick 0 0 0\r\n"
  wait_for_server_line $server_id {USER successful} "USER successful ($nick)"

  return $cid
}

# --- authenticate clients one-by-one so server logs are unambiguous ---
set alice [start_and_auth $server_id $host $port $pass "alice" "Alice Wonderland"]
set bob   [start_and_auth $server_id $host $port $pass "bob"   "Bob Builder"]

# --- alice -> bob ---
set spawn_id $alice
send "PRIVMSG bob :hi bob, it's alice\r\n"

set spawn_id $bob
expect {
  -re {(^|:).*PRIVMSG[[:space:]]+bob[[:space:]]+:hi bob, it's alice} {}
  -re {alice.*PRIVMSG.*bob} {}
  timeout { puts "FAIL: bob didn't get PM from alice"; exit 1 }
}

# --- bob -> alice ---
set spawn_id $bob
send "PRIVMSG alice :hey alice\r\n"

set spawn_id $alice
expect {
  -re {(^|:).*PRIVMSG[[:space:]]+alice[[:space:]]+:hey alice} {}
  -re {bob.*PRIVMSG.*alice} {}
  timeout { puts "FAIL: alice didn't get PM from bob"; exit 1 }
}

puts "PASS: two-way PM (with server stdout checks)"

# --- cleanup: close clients and stop server ---
catch { close -i $alice }
catch { wait  -i $alice }
catch { close -i $bob }
catch { wait  -i $bob }

# try to stop server gently; fall back to SIGTERM if needed
catch { exec kill -INT $server_pid }
after 150
if {[catch { exec kill -0 $server_pid }]} {
  # already gone
} else {
  catch { exec kill $server_pid }
}
